var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "What is CRaC? Coordinated Restore at Checkpoint (CRaC) is a JDK project that allows you to start Java programs with a shorter time to first transaction, combined with less time and resources to achieve full code speed.\nCRaC IN YOUR CODE USING CRaC\nCRaC API 1.4.0 NOW AVAILABLE Why CRaC? The CRaC (Coordinated Restore at Checkpoint) Project researches the coordination of Java programs with mechanisms to checkpoint (make an image of, snapshot) a Java instance while executing. Restoring from the image could solve some of the problems with the start-up and warm-up times. The primary aim of the Project is to develop a new standard mechanism-agnostic API to notify Java programs about the checkpoint and restore events. Other research activities will include, but will not be limited to, integration with existing checkpoint/restore mechanisms and development of new ones, changes to JVM and JDK to make images smaller and ensure they are correct.\nUSED BY Spring Boot Example project More info\nQuarkus Example project More info\nMicronaut Example project More info\nAWS Lambda Example project More info\nFeatures Super fast startup Startup within milliseconds from a checkpoint. Checkpoint creation Generate checkpoints from code or with jcmd. Restore from checkpoint Restore on the same machine, or many others from a checkpoint. Minimal code changes Use frameworks, or implement the CRaC API to assist in the creation and restore of checkpoints Framework support Several frameworks (Spring Boot, Quarkus, Micronaut,...) offer CRaC support out-of-the-box. Use it in the Cloud AWS Lambda has CRaC functionality integrated, no code changes needed!",
    "description": "What is CRaC? Coordinated Restore at Checkpoint (CRaC) is a JDK project that allows you to start Java programs with a shorter time to first transaction, combined with less time and resources to achieve full code speed.\nCRaC IN YOUR CODE USING CRaC\nCRaC API 1.4.0 NOW AVAILABLE Why CRaC? The CRaC (Coordinated Restore at Checkpoint) Project researches the coordination of Java programs with mechanisms to checkpoint (make an image of, snapshot) a Java instance while executing. Restoring from the image could solve some of the problems with the start-up and warm-up times. The primary aim of the Project is to develop a new standard mechanism-agnostic API to notify Java programs about the checkpoint and restore events. Other research activities will include, but will not be limited to, integration with existing checkpoint/restore mechanisms and development of new ones, changes to JVM and JDK to make images smaller and ensure they are correct.",
    "tags": [],
    "title": "Coordinated Restore at Checkpoint",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Frameworks with CRaC integration",
    "content": "Spring Boot provides CRaC support as of version 3.2, for more details see:\nScale to zero with Spring and Project CRaC Spring Boot documentation for Project CRaC support Spring Framework documentation for Project CRaC support Examples:\nhttps://github.com/CRaC/example-spring-boot https://github.com/sdeleuze/spring-boot-crac-demo",
    "description": "Spring Boot provides CRaC support as of version 3.2, for more details see:\nScale to zero with Spring and Project CRaC Spring Boot documentation for Project CRaC support Spring Framework documentation for Project CRaC support Examples:\nhttps://github.com/CRaC/example-spring-boot https://github.com/sdeleuze/spring-boot-crac-demo",
    "tags": [],
    "title": "SpringBoot",
    "uri": "/frameworks/spring-boot/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint",
    "content": "Several frameworks provide CRaC functionality out-of-the-box.\nWhat is Coordinated Restore at Checkpoint? Startup Improvement Results",
    "description": "Several frameworks provide CRaC functionality out-of-the-box.\nWhat is Coordinated Restore at Checkpoint? Startup Improvement Results",
    "tags": [],
    "title": "About CRaC",
    "uri": "/about/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Extra info about CRaC",
    "content": "Best practices for implementing CRaC support in your application/library This guide assumes you are already familiar with the concepts and Resource API; please check out the step-by-step guide for those.\nImplementing Resource as inner class In order to encapsulate the functionality, the Resource interface is sometimes not implemented directly by the component but we rather create an (anonymous) inner class. However it is not sufficient to pass this resource to the Context.register() method; Global Context tracks resources using weak references. As there is no unregister method on the Context, had a strong reference been used this would prevent the component from being garbage-collected when the application releases it. Therefore the class implementing Resource should be stored inside the component (in a field) to prevent garbage-collection:\npublic class Component { private final Resource cracHandler; public Component() { /* other initialization */ cracHandler = new Resource() { @Override public void beforeCheckpoint(Context\u003c? extends Resource\u003e context) { /* ... */ } @Override public void afterRestore(Context\u003c? extends Resource\u003e context) { /* ... */ } }; /* Had we used just .register(new Resource() { ... }) in here it would be immediately garbage-collected. */ Core.getGlobalContext().register(cracHandler); } } Component lifecycle Applications and its components are often designed with a simple lifecycle in mind; the application boots, then it is actively used, and in the end it enters shutdown and finally ends up in a terminated state, unable to start back. If the application needs the functionality again the component is re-created. This allows simpler reasoning and some performance optimizations by making fields final, or not protecting the access to an uninitialized component as the developer knows that it is not published yet.\nWhile usually most of the application can stay as-is, CRaC extends the lifecycle of some components by adding the transition from active to a suspended state and back. In the suspended state, until the whole VM is terminated or before the component is restored, the rest of that application is still running and could access the component - e.g. a pool of network connections - and would find this component to be unusable at that moment. One solution is to block the thread and unblock it when the component is ready for serving again.\nThe implementation of this synchronization depends mostly on the threading model of the application. We will refer to the synchronized component as resource, even though it might not implement the Resource interface directly.\nGeneral case: unknown number of threads arriving randomly The most general case is when we don’t have any guarantees about who’s calling into the resource. In order to block any access to that we will use the java.util.concurrent.ReadWriteLock:\npublic class ConnectionPool implements Resource { private final ReadWriteLock lock = new ReentrantReadWriteLock(); private final Lock readLock = lock.readLock(); private final Lock writeLock = lock.writeLock(); /* Constructor registers this Resource */ public Connection getConnection() { readLock.lock(); try { /* actual code fetching the connection */ /* In this example the access to the connection itself is not protected and the application must be able to handle a closed connection. */ } finally { readLock.unlock(); } } @Override public void beforeCheckpoint(Context\u003c? extends Resource\u003e context) throws Exception { writeLock.lock(); /* close all connections */ /* Note: if this method throws an exception CRaC will try to restore the resource by calling afterRestore() - we don't need to unlock the lock here */ } @Override public void afterRestore(Context\u003c? extends Resource\u003e context) throws Exception { try { /* initialize connections if needed */ } finally { writeLock.unlock(); } } } This solution has the obvious drawback of adding contention on the hot path, the getConnection() method. Even though readers won’t block each other, the implementation of read locking likely has to perform some atomic writes which are not cost free.\nCRaC might eventually provide an optimized version for this read-write locking pattern that would move most of the cost to the write lock (as we don’t need to optimize for checkpoint performance).\nOne or known number of periodically arriving threads When there is only a single thread, e.g. fetching a task from a queue, or known number of parties that arrive to the component often enough we can apply a more efficient solution. Let’s take an example of a resource logging data to a file, and assume that the checkpoint notifications are invoked from another thread (that is the case when it is triggered through jcmd \u003cpid\u003e JDK.checkpoint). We will use the java.util.concurrent.Phaser rather than j.u.c.CyclicBarrier as the former has a non-interruptible version of waiting.\npublic class Logger implements Resource { private final int N = 1; // number of threads calling write() private volatile Phaser phaser; public void write(Chunk data) throws IOException { checkForCheckpoint(); /* do the actual write */ } public void checkForCheckpoint() throws IOException { Phaser phaser = this.phaser; if (phaser != null) { if (phaser.arriveAndAwaitAdvance() \u003c 0) { throw new IllegalStateException(\"Shouldn't terminate here\"); } /* now the resource is suspended */ if (phaser.arriveAndAwaitAdvance() \u003c 0) { throw new IOException(\"File could not be open after restore\"); } } } @Override public void beforeCheckpoint(Context\u003c? extends Resource\u003e context) throws Exception { phaser = new Phaser(N + 1); // +1 for self phaser.arriveAndAwaitAdvance(); /* close file being written */ } @Override public void afterRestore(Context\u003c? extends Resource\u003e context) throws Exception { Phaser phaser = this.phaser; this.phaser = null; try { /* reopen the file */ phaser.arriveAndAwaitAdvance(); } catch (Exception e) { phaser.forceTermination(); throw e; } } } This synchronization requires only one volatile read on each write() call, that is generally a cheap operation. However if one of the expected threads is waiting for a long time the checkpoint would be blocked. This could be mitigated by using shorter timeouts (e.g. if the thread is polling a queue) or even actively interrupting it from the beforeCheckpoint method.\nEventloop model Another specific case is the eventloop model where the application uses single thread for all operations in the resource and already has a mechanism to schedule task in that eventloop. Let’s take an example of a resource sending a heartbeat message.\npublic class HeartbeatManager implements Runnable, Resource { public final ScheduledExecutorService eventloop; // single-threaded public boolean suspended; public HeartbeatManager(Executor eventloop) { eventloop.scheduleAtFixedRate(this, 0, 1, TimeUnit.MINUTES); } @Override public void run() { /* send heartbeat message */ } @Override public void beforeCheckpoint(Context\u003c? extends Resource\u003e context) throws Exception { synchronized (this) { HeartbeatManager self = this; executor.execute(() -\u003e { synchronized (self) { self.suspended = true; self.notify(); while (self.suspended) { self.wait(); } } }) while (!suspended) { wait(); } } /* shutdown */ } @Override public void afterRestore(Context\u003c? extends Resource\u003e context) throws Exception { /* restore */ synchronized (this) { suspended = false; notify(); } } } Beware that if the single-threaded executor is shared between several components this solution is not applicable in the current form as one resource would block and the others would not be able to get suspended. In this case it might make sense to centralize the control into one resource per executor; this is out of scope of this document, though.\nAlso Note one detail in the example above: if the application is stopped for a long time the task scheduled by the ScheduledExecutorService.scheduleAtFixedRate(...) would try to keep up after restore and perform all the missed invocations. Handling that should be a part of the beforeCheckpoint procedure, cancelling the task and rescheduling it again in afterRestore.",
    "description": "Best practices for implementing CRaC support in your application/library This guide assumes you are already familiar with the concepts and Resource API; please check out the step-by-step guide for those.\nImplementing Resource as inner class In order to encapsulate the functionality, the Resource interface is sometimes not implemented directly by the component but we rather create an (anonymous) inner class. However it is not sufficient to pass this resource to the Context.register() method; Global Context tracks resources using weak references. As there is no unregister method on the Context, had a strong reference been used this would prevent the component from being garbage-collected when the application releases it. Therefore the class implementing Resource should be stored inside the component (in a field) to prevent garbage-collection:",
    "tags": [],
    "title": "Best Practices",
    "uri": "/extra-info/best-practices/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Frameworks with CRaC integration",
    "content": "Basic CRaC support is a part of Quarkus since 2.10.0.\nExample: https://github.com/CRaC/example-quarkus",
    "description": "Basic CRaC support is a part of Quarkus since 2.10.0.\nExample: https://github.com/CRaC/example-quarkus",
    "tags": [],
    "title": "Quarkus",
    "uri": "/frameworks/quarkus/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e About CRaC",
    "content": "Coordinated Restore at Checkpoint (CRaC) is an OpenJDK feature that provides a fast start and immediate performance for Java applications.\nA Java application and JVM are started from an image in a warmed-up form. The image is created from a running Java instance at arbitrary point of time (“checkpoint”). The start from the image (“restore”) continues from the point when checkpoint was made.\nThe restore in general is faster than initialization. After the restore, Java runtime performance is also on-par with the one at the checkpoint. So, after proper warm-up before the checkpoint, restored Java instance is able to deliver the best runtime characteristics immediately.\nCoordinated Restore undisruptively introduces new before-checkpoint and after-restore phases in Java application lifecycle. In contrast with uncoordinated checkpoint/restore, coordination allows restored Java applications to behave differently. For example, it is possible to react on changes in execution environment that happened since checkpoint was done.\nCRaC implementation creates the checkpoint only if the whole Java instance state can be stored in the image. Resources like open files or sockets are cannot, so it is required to release them when checkpoint is made. CRaC emits notifications for an application to prepare for the checkpoint and return to operating state after restore.\nWith more Java frameworks and libraries adopting CRaC, applications can benefit with little or no changes in the code. Moreover, the required amount of changes in the resource management code tends to be small, see examples below.\nCoordinated Restore is not tied to a particular checkpoint/restore implementation and will able to use existing ones (CRIU, docker checkpoint/restore) and ones yet to be developed.\nCPU Features When running checkpoint and restore on different computers you may seen an error message during restore\nYou have to specify -XX:CPUFeatures=[...] together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features [...]; missing features of this CPU are [...] See more details about the CPU Features configuration.\nProgrammer’s flow Programs may need to be adjusted for use with Coordinated Restore at Checkpoint.\nA step-by-step guide and best practices guide provide information on how to implement the CRaC support in the code.\nAnother option is to use an existing framework with CRaC support.\nNo changes required:\nMicronaut: https://github.com/CRaC/example-micronaut Quarkus Hello World: https://github.com/CRaC/example-quarkus Spring Boot: https://github.com/CRaC/example-spring-boot With configuration changes:\nQuarkus Super Heroes migration shows a walkthrough for making an existing non-trivial Quarkus application CRaC-able. API The CRaC API is not a part of Java SE specification. We hope that eventually it will be there, until then there are different packages that can be used.\njdk.crac javadoc This is the API that is implemented in the CRaC JDK.\nPlease refer to org.crac if you are looking to add CRaC support to a code that should also work on a regular JDK/JRE.\norg.crac The package is provided by org.crac compatibility library.\nThe org.crac is designed to provide smooth CRaC adoption. Users of the library can build against and use CRaC API on Java runtimes with jdk.crac, javax.crac, or without any implementation.\nIn compile-time, org.crac package totally mirrors jdk.crac and javax.crac. In runtime, org.crac uses reflection to detect CRaC implementation. If the one is available, all requests to org.crac are passed to the implementation. Otherwise, requests are forwarded to a dummy implementation. The dummy implementation allows an application to run but not to use CRaC:\nresources can be registered for notification, checkpoint request fails with an exception. Implementation details Current OpenJDK implementation is based on using the CRIU project to create the image.\nCRIU hosts a few changes made to improve CRaC usability.\nYou can read more about debugging C/R issues in your application in the debug guide.\nWorkarounds Sometimes it might be difficult to alter the application to properly coordinate with the checkpoint (e.g. due to a code in a library you cannot modify). As a temporary workaround you can configure file-descriptor policies.",
    "description": "Coordinated Restore at Checkpoint (CRaC) is an OpenJDK feature that provides a fast start and immediate performance for Java applications.\nA Java application and JVM are started from an image in a warmed-up form. The image is created from a running Java instance at arbitrary point of time (“checkpoint”). The start from the image (“restore”) continues from the point when checkpoint was made.\nThe restore in general is faster than initialization. After the restore, Java runtime performance is also on-par with the one at the checkpoint. So, after proper warm-up before the checkpoint, restored Java instance is able to deliver the best runtime characteristics immediately.",
    "tags": [],
    "title": "What is Coordinated Restore at Checkpoint?",
    "uri": "/about/about-crac/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e About CRaC",
    "content": "CRaC support was implemented in a few frameworks with the following results. The source code can be found in the Projects with CRaC support section.\nThe environment laptop with Intel i7-5500U, 16Gb RAM and SSD. Linux kernel 5.7.4-arch1-1 data was collected in container running ubuntu:18.04 based image host operating system: archlinux jdk14-crac build\nHow to reproduce To reproduce you need to create a workspace directory and clone along next repositories:\nutils docs (this repo) example-spring-boot example-quarkus example-micronaut example-xml-transform You need to build examples according to the Projects with CRaC support section.\nThen run\nhost$ docker build -t full-bench -f Dockerfile.full-bench utils host$ docker run -it --privileged -v $HOME:$HOME -v $PWD:$PWD -w $PWD full-bench cont# JDK=\u003cpath/to/jdk\u003e bash ./utils/full-bench.sh collect ... cont# exit host$ bash ./utils/full-bench.sh parse host$ cp *.data docs host$ make -C docs Last command regenerates graphs in the docs.",
    "description": "CRaC support was implemented in a few frameworks with the following results. The source code can be found in the Projects with CRaC support section.\nThe environment laptop with Intel i7-5500U, 16Gb RAM and SSD. Linux kernel 5.7.4-arch1-1 data was collected in container running ubuntu:18.04 based image host operating system: archlinux jdk14-crac build\nHow to reproduce To reproduce you need to create a workspace directory and clone along next repositories:\nutils docs (this repo) example-spring-boot example-quarkus example-micronaut example-xml-transform You need to build examples according to the Projects with CRaC support section.",
    "tags": [],
    "title": "Startup Improvement Results",
    "uri": "/about/results/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint",
    "content": "CRaC deployment scheme reflects the need to collect data required for Java application initialization and warm-up.\na Java application (or container) is deployed in the canary environment the app processes canary requests that triggers class loading and JIT compilation the running application is checkpointed by some mean this creates the image of the JVM and application; the image is considered as a part of a new deployment bundle the Java application with the image are deployed in the production environment the restored Java process uses loaded classes from and JIT code from the immediately Read more Java Runtime with CRaC Support Implementing CRaC in your Application Creating a Checkpoint and Restoring from Checkpoint",
    "description": "CRaC deployment scheme reflects the need to collect data required for Java application initialization and warm-up.\na Java application (or container) is deployed in the canary environment the app processes canary requests that triggers class loading and JIT compilation the running application is checkpointed by some mean this creates the image of the JVM and application; the image is considered as a part of a new deployment bundle the Java application with the image are deployed in the production environment the restored Java process uses loaded classes from and JIT code from the immediately Read more Java Runtime with CRaC Support Implementing CRaC in your Application Creating a Checkpoint and Restoring from Checkpoint",
    "tags": [],
    "title": "Using CRaC",
    "uri": "/use/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint",
    "content": "Some example implementations are available on these pages:\nJetty Quarkus Super Heroes",
    "description": "Some example implementations are available on these pages:\nJetty Quarkus Super Heroes",
    "tags": [],
    "title": "Example implementations",
    "uri": "/examples/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Using CRaC",
    "content": "To use the CRAC functionality, you need a Java runtime that has support for CRaC integrated.\nOpenJDK CRaC LATEST OPENJDK CRAC RELEASE The OpenJDK CRaC Project is developed in the GitHub repository github.com/openjdk/crac.\nNOTE: The JDK archive should be extracted with sudo.\n$ sudo tar zxf \u003cjdk\u003e.tar.gz When using CRaC, if you see an Operation not permitted error, you may have to update your criu permissions with:\nsudo chown root:root $JAVA_HOME/lib/criu sudo chmod u+s $JAVA_HOME/lib/criu Azul Zulu Builds of OpenJDK DOWNLOAD AZUL ZULU WITH CRAC Azul integrated full CRaC functionality for Linux/x64 and Linux/Arm64, in version 17, 21, and 22 of Azul Zulu Builds of OpenJDK. This means, for now, you can run an application with CRaC on any system thanks to the crac.org dependency, but only on the specified OS systems the CRaC functionality in the JVM will work.\nAs of January 2024, downloads are also available for Windows and macOS of Zulu with CRaC support, but only for development purposes. With these runtimes you are able to simulate the CRaC functionality. When you request a checkpoint, it is created and immediately restored without dumping the checkpoint to disk. This enables you to develop and test the CRaC functionality on these platforms, so you can deploy your application with confidence on Linux.\nAWS Lambda SnapStart MORE INFO ABOUT AWS LAMBDA SNAPSTART AWS Lambda SnapStart is a performance optimization developed by AWS that can significantly improve the startup time for applications. This feature delivers up to 10x faster function startup times for latency-sensitive Java applications at no extra cost, and with minimal or no code changes.",
    "description": "To use the CRAC functionality, you need a Java runtime that has support for CRaC integrated.\nOpenJDK CRaC LATEST OPENJDK CRAC RELEASE The OpenJDK CRaC Project is developed in the GitHub repository github.com/openjdk/crac.\nNOTE: The JDK archive should be extracted with sudo.\n$ sudo tar zxf \u003cjdk\u003e.tar.gz When using CRaC, if you see an Operation not permitted error, you may have to update your criu permissions with:",
    "tags": [],
    "title": "Java Runtime with CRaC Support",
    "uri": "/use/crac-runtime/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Extra info about CRaC",
    "content": "Debugging checkpoint and restore failures This guide will help you identify common problems when the checkpoint operation does not work.\nFailures in native C/R When the checkpoint operation fails in the native part, there is usually little information in the stack trace of the exception:\nCR: Checkpoint ... JVM: invalid info for restore provided: queued code -1 Exception in thread \"main\" jdk.crac.CheckpointException at java.base/jdk.crac.Core.checkpointRestore1(Core.java:159) at java.base/jdk.crac.Core.checkpointRestore(Core.java:264) at java.base/jdk.crac.Core.checkpointRestore(Core.java:249) at Main.main(Main.java:6) Currently the C/R depends on the CRIU project, particularly on the CRaC fork. This requires extensive privileges (capabilities) and therefore usually runs as root granted through the SUID bit. Therefore the first check is would be whether this is true:\n$ ls -la $JAVA_HOME/lib/criu -rwsr-xr-x 1 root root 6347736 Mar 24 16:33 /opt/openjdk-17-crac+5_linux-x64/lib/criu ^ ^ | Check that the file is owner by the root user Check that the SUID bit is set If this is not the case please update it:\nsudo chown root:root /path/to/criu sudo chmod u+s /path/to/criu This might not be sufficient if Java is running in a container; checkpoint requires running it with the --privileged flag (or --cap-add all). Restore can be executed without these privileges under root user.\nWhen you confirm that this is set correctly but the checkpoint still fails you can get additional insight from the dump4.log file located in the image directory (-XX:CRaCCheckpointTo).\nFile descriptors in Java code Before the checkpoint the application has to isolate itself from the outer world: this means closing all file descriptors except the standard input, output and error, and few other (e.g. pointing to JDK or files on the classpath). If the application fails to do so the checkpoint fails with an exception like below:\nException in thread \"main\" jdk.crac.CheckpointException at java.base/jdk.crac.Core.checkpointRestore1(Core.java:129) at java.base/jdk.crac.Core.checkpointRestore(Core.java:264) at java.base/jdk.crac.Core.checkpointRestore(Core.java:249) at ... (application code) Suppressed: jdk.crac.impl.CheckpointOpenFileException: FileDescriptor 4 left open: /foo/bar (regular) Use -Djdk.crac.collect-fd-stacktraces=true to find the source. at java.base/java.io.FileDescriptor.beforeCheckpoint(FileDescriptor.java:391) at java.base/java.io.FileDescriptor$Resource.beforeCheckpoint(FileDescriptor.java:84) at java.base/jdk.crac.impl.PriorityContext$SubContext.invokeBeforeCheckpoint(PriorityContext.java:107) at java.base/jdk.crac.impl.OrderedContext.runBeforeCheckpoint(OrderedContext.java:70) at java.base/jdk.crac.impl.AbstractContextImpl.beforeCheckpoint(AbstractContextImpl.java:81) at java.base/jdk.crac.impl.AbstractContextImpl.invokeBeforeCheckpoint(AbstractContextImpl.java:41) at java.base/jdk.crac.impl.PriorityContext.runBeforeCheckpoint(PriorityContext.java:70) at java.base/jdk.crac.impl.AbstractContextImpl.beforeCheckpoint(AbstractContextImpl.java:81) at java.base/jdk.internal.crac.JDKContext.beforeCheckpoint(JDKContext.java:97) at java.base/jdk.crac.impl.AbstractContextImpl.invokeBeforeCheckpoint(AbstractContextImpl.java:41) at java.base/jdk.crac.impl.OrderedContext.runBeforeCheckpoint(OrderedContext.java:70) at java.base/jdk.crac.impl.AbstractContextImpl.beforeCheckpoint(AbstractContextImpl.java:81) at java.base/jdk.crac.Core.checkpointRestore1(Core.java:127) ... 5 more The top level CheckpointException wraps all problems as its suppressed exceptions. Here we can see that having file /foo/bar open as FD 4 prevents the checkpoint but unless we know what part of the application opens this file there is not anything actionable. Therefore we will run this with -Djdk.crac.collect-fd-stacktraces=true as the exception message suggests:\nException in thread \"main\" jdk.crac.CheckpointException at java.base/jdk.crac.Core.checkpointRestore1(Core.java:129) at java.base/jdk.crac.Core.checkpointRestore(Core.java:264) at java.base/jdk.crac.Core.checkpointRestore(Core.java:249) at ... (application code) Suppressed: jdk.crac.impl.CheckpointOpenFileException: FileDescriptor 4 left open: /etc/passwd (regular) at java.base/java.io.FileDescriptor.beforeCheckpoint(FileDescriptor.java:391) at java.base/java.io.FileDescriptor$Resource.beforeCheckpoint(FileDescriptor.java:84) at java.base/jdk.crac.impl.PriorityContext$SubContext.invokeBeforeCheckpoint(PriorityContext.java:107) at java.base/jdk.crac.impl.OrderedContext.runBeforeCheckpoint(OrderedContext.java:70) at java.base/jdk.crac.impl.AbstractContextImpl.beforeCheckpoint(AbstractContextImpl.java:81) at java.base/jdk.crac.impl.AbstractContextImpl.invokeBeforeCheckpoint(AbstractContextImpl.java:41) at java.base/jdk.crac.impl.PriorityContext.runBeforeCheckpoint(PriorityContext.java:70) at java.base/jdk.crac.impl.AbstractContextImpl.beforeCheckpoint(AbstractContextImpl.java:81) at java.base/jdk.internal.crac.JDKContext.beforeCheckpoint(JDKContext.java:97) at java.base/jdk.crac.impl.AbstractContextImpl.invokeBeforeCheckpoint(AbstractContextImpl.java:41) at java.base/jdk.crac.impl.OrderedContext.runBeforeCheckpoint(OrderedContext.java:70) at java.base/jdk.crac.impl.AbstractContextImpl.beforeCheckpoint(AbstractContextImpl.java:81) at java.base/jdk.crac.Core.checkpointRestore1(Core.java:127) ... 5 more Caused by: java.lang.Exception: This file descriptor was created by main at epoch:1684328308663 here at java.base/java.io.FileDescriptor$Resource.\u003cinit\u003e(FileDescriptor.java:75) at java.base/java.io.FileDescriptor.\u003cinit\u003e(FileDescriptor.java:104) at java.base/java.io.FileInputStream.\u003cinit\u003e(FileInputStream.java:154) at java.base/java.io.FileInputStream.\u003cinit\u003e(FileInputStream.java:111) at java.base/java.io.FileReader.\u003cinit\u003e(FileReader.java:60) at ... (application code calling new FileReader(\"/foo/bar\") ) ... 2 more The cause is recorded when the FD is opened, the message shows thread name (main) and epoch timestamp (some FDs are open early during VM initialization when it is not possible to format the timestamp to a human-readable format). This information can help you identify the component that does not close the FD during checkpoint.\nFile descriptors in native code When the file descriptor is opened without assisting FileDescriptor instance CRaC still discovers this before the checkpoint but won’t display any stack trace:\nException in thread \"main\" jdk.crac.CheckpointException at java.base/jdk.crac.Core.checkpointRestore1(Core.java:159) at java.base/jdk.crac.Core.checkpointRestore(Core.java:264) at java.base/jdk.crac.Core.checkpointRestore(Core.java:249) at ... (application code) Suppressed: jdk.crac.impl.CheckpointOpenResourceException: FD fd=4 type=fifo path=pipe:[8953321] at java.base/jdk.crac.Core.translateJVMExceptions(Core.java:102) at java.base/jdk.crac.Core.checkpointRestore1(Core.java:163) ... 5 more In this case we need to find the source of the syscall returning the new file descriptor in native code. One tool that can help with that is strace:\nstrace -f -o /tmp/strace.txt java ... This will follow forking process/thread (-f) and store the log in /tmp/strace.txt. There we can find that FDs 4 and 5 were created through the pipe2 syscall:\n1204483 pipe2([4, 5], 0) = 0 1204483 fcntl(4, F_GETFL) = 0 (flags O_RDONLY) 1204483 fcntl(4, F_SETFL, O_RDONLY|O_NONBLOCK) = 0 1204483 fcntl(5, F_GETFL) = 0x1 (flags O_WRONLY) 1204483 fcntl(5, F_SETFL, O_WRONLY|O_NONBLOCK) = 0 Other common syscalls opening file descriptors are e.g. openat, dup or dup2. We will run strace once more, but this time filtering only one syscall (-e pipe2), and recording stacks (-k):\nstrace -f -o /tmp/strace.txt -e pipe2 -k java ... 1204650 pipe2([4, 5], 0) = 0 \u003e /usr/lib/x86_64-linux-gnu/libc.so.6(pipe+0xd) [0x11522d] \u003e /path/to/my/jdk/lib/libnio.so() [0x84bf] \u003e unexpected_backtracing_error [0x7f2f1140f6cb] We can see that the pipe method was called from libnio.so This example used a debug build of JDK so we still have symbols, so we can find the function with address 0x84bf:\nobjdump -d --start-address 0x84bf /path/to/my/jdk/lib/libnio.so | head /path/to/my/jdk/lib/libnio.so: file format elf64-x86-64 Disassembly of section .text: 00000000000084bf \u003cJava_sun_nio_ch_IOUtil_makePipe+0x1f\u003e: 84bf:\t85 c0 test %eax,%eax 84c1:\t0f 88 c1 00 00 00 js 8588 \u003cJava_sun_nio_ch_IOUtil_makePipe+0xe8\u003e 84c7:\t44 8b 65 d8 mov -0x28(%rbp),%r12d Here we can track down the invocation to native method makePipe() in sun.nio.ch.IOUtil. You can debug your application putting a breakpoint on that method and find the rest of the Java call stack, or check manually all usages.\nRestore conflict of PIDs Errors can happen during restore, too. While on baremetal deployments PIDs usually don’t clash, in containers starting from PID 1 this is more likely. The error then looks like this:\nError (criu/cr-restore.c:1506): Can't fork for 9: File exists Error (criu/cr-restore.c:2593): Restoring FAILED. The message is a bit misleading: the error is not related to files. In this example CRIU tried to restore a process or thread with PID 9 but found that there is already an existing process/thread with this PID. If you check ps faux it’s possible that you won’t find that process - the restore itself spins up some processes that could clash and die due to unsuccessful restore. If the clash happens due to restoring process it might be sufficient to attempt the restore several times, until there is no conflict.\nThe error above should not be confused with another one:\nError (criu/cr-restore.c:1506): Can't fork for 9: Read-only file system Error (criu/cr-restore.c:2593): Restoring FAILED. Error (criu/cr-restore.c:1823): Pid 20 do not match expected 9 This is rather a sign that CRIU has insufficient privileges to write into ns_last_pid and/or call clone3, a syscall forking the process with a specific PID. CRIU can work around the missing permissions if it can cycle up to the desired PID, but if it is lower than the current PID it won’t cycle through the full range set in the operating system.\nOne trick that can be used in containers is to ensure that before the checkpoint PIDs are higher than anything needed for the restore, either writing /proc/sys/kernel/ns_last_pid or cycling dummy processes until ns_last_pid is higher than the required value (128 might be a good starting point).\nFurther debugging of restore During restore CRIU writes its log into standard output with errors-only verbosity level (1). Debug-level (4) output can be enabled using VM option -XX:CREngine=criuengine,--verbosity=4,--log-file=/path/to/log.txt by passing these options to CRIU.",
    "description": "Debugging checkpoint and restore failures This guide will help you identify common problems when the checkpoint operation does not work.\nFailures in native C/R When the checkpoint operation fails in the native part, there is usually little information in the stack trace of the exception:\nCR: Checkpoint ... JVM: invalid info for restore provided: queued code -1 Exception in thread \"main\" jdk.crac.CheckpointException at java.base/jdk.crac.Core.checkpointRestore1(Core.java:159) at java.base/jdk.crac.Core.checkpointRestore(Core.java:264) at java.base/jdk.crac.Core.checkpointRestore(Core.java:249) at Main.main(Main.java:6) Currently the C/R depends on the CRIU project, particularly on the CRaC fork. This requires extensive privileges (capabilities) and therefore usually runs as root granted through the SUID bit. Therefore the first check is would be whether this is true:",
    "tags": [],
    "title": "Debugging",
    "uri": "/extra-info/debugging/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Using CRaC",
    "content": "WARNING: next is a proposal phase and is subject to change\nPlease refer to the Projects with CRaC support section, step-by-step guide or best practices guide to get an application with CRaC support. The rest of the section is written for the spring-boot example.\nFor the first, Java command line parameter -XX:CRaCCheckpointTo=PATH defines a path to store the image and also allows the java instance to be checkpointed. By the current implementation, the image is a directory with image files. The directory will be created if it does not exist, but no parent directories are created.\nexport JAVA_HOME=./jdk $JAVA_HOME/bin/java -XX:CRaCCheckpointTo=cr -jar target/example-spring-boot-0.0.1-SNAPSHOT.jar For the second, in another console: supply canary worload …\n$ curl localhost:8080 Greetings from Spring Boot! … and make a checkpoint by a jcmd command\n$ jcmd target/example-spring-boot-0.0.1-SNAPSHOT.jar JDK.checkpoint 1563568: Command executed successfully Due to current jcmd implementation, success is always reported in jcmd output, problems are reported in the console of the application.\nAnother option to make the checkpoint is to invoke the jdk.crac.Core.checkpointRestore() method (see API). More options are possible in the future.\nFor the third, restore the cr image by -XX:CRaCRestoreFrom=PATH option\n$JAVA_HOME/bin/java -XX:CRaCRestoreFrom=cr",
    "description": "WARNING: next is a proposal phase and is subject to change\nPlease refer to the Projects with CRaC support section, step-by-step guide or best practices guide to get an application with CRaC support. The rest of the section is written for the spring-boot example.\nFor the first, Java command line parameter -XX:CRaCCheckpointTo=PATH defines a path to store the image and also allows the java instance to be checkpointed. By the current implementation, the image is a directory with image files. The directory will be created if it does not exist, but no parent directories are created.",
    "tags": [],
    "title": "Implementing CRaC in your Application",
    "uri": "/use/implement-crac/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Example implementations",
    "content": "Step-by-step CRaC support for a Jetty app A program can be restored in a different environment compared to the one where it was checkpointed. Dependencies on the environment need to be detected and a coordination code need to be created to update the dependencies after restore. Such dependencies are open handles for operating system resources like files and sockets, cached hostname and environment, registration in remote services, …\nFor now, CRaC implementation checks for open files and sockets at the checkpoint. The checkpoint is aborted if one is found, also, an exception is thrown with a description of the file name or socket address.\nThis document describes how to implement CRaC support on an example of a sample Jetty application.\nFull source code for this section can be found in example-jetty repo. Commit history corresponds to the steps of the tutorial with greater details.\nA simple Jetty application will serve as a starting point:\nclass ServerManager { Server server; public ServerManager(int port, Handler handler) throws Exception { server = new Server(8080); server.setHandler(handler); server.start(); } } public class App extends AbstractHandler { static ServerManager serverManager; public void handle(...) { response.getWriter().println(\"Hello World\"); } public static void main(String[] args) throws Exception { serverManager = new ServerManager(8080, new App()); } } The main thread creates an instance of ServerManager that starts managing a jetty instance. The thread then exits, leaving the jetty instance a single non-daemon thread.\nBuild and start the example. Java argument -XX:CRaCCheckpointTo=PATH enables CRaC and defines a path to store the image.\nUse CRaC API requires adding org.crac as a maven dependency,\nIn compile-time, org.crac package totally mirrors jdk.crac and javax.crac. In runtime, org.crac uses reflection to detect CRaC implementation. If the one is available, all requests to org.crac are passed to the implementation. Otherwise, requests are forwarded to a dummy implementation. \u003cdependency\u003e \u003cgroupId\u003eorg.crac\u003c/groupId\u003e \u003cartifactId\u003ecrac\u003c/artifactId\u003e \u003cversion\u003e0.1.3\u003c/version\u003e \u003c/dependency\u003e $ mvn package $ $JAVA_HOME/bin/java -XX:CRaCCheckpointTo=cr -jar target/example-jetty-1.0-SNAPSHOT.jar 2020-06-29 18:01:32.944:INFO::main: Logging initialized @293ms to org.eclipse.jetty.util.log.StdErrLog 2020-06-29 18:01:33.003:INFO:oejs.Server:main: jetty-9.4.30.v20200611; built: 2020-06-11T12:34:51.929Z; git: 271836e4c1f4612f12b7bb13ef5a92a927634b0d; jvm 14-internal+0-adhoc..jdk 2020-06-29 18:01:33.045:INFO:oejs.AbstractConnector:main: Started ServerConnector@319b92f3{HTTP/1.1, (http/1.1)}{0.0.0.0:8080} 2020-06-29 18:01:33.047:INFO:oejs.Server:main: Started @406ms Warm-up the application:\n$ curl localhost:8080 Hello World Use jcmd to trigger checkpoint:\n$ jcmd target/example-jetty-1.0-SNAPSHOT.jar JDK.checkpoint 80694: Command executed successfully Current jcmd implementation always reports success. For now, refer to the console of the application for diagnostic output. In the future all diagnostic output will be provided by jcmd.\nThe expected output of the application is next. The checkpoint cannot be created with a listening socket, the exception is thrown.\njdk.crac.impl.CheckpointOpenSocketException: tcp6 localAddr :: localPort 8080 remoteAddr :: remotePort 0 at java.base/jdk.crac.Core.translateJVMExceptions(Core.java:80) at java.base/jdk.crac.Core.checkpointRestore1(Core.java:137) at java.base/jdk.crac.Core.checkpointRestore(Core.java:177) at java.base/jdk.crac.Core.lambda$checkpointRestoreInternal$0(Core.java:194) at java.base/java.lang.Thread.run(Thread.java:832) Simpliest way to ensure the socket is closed is to shutdown the Jetty instance when checkpoint is started and start the instance again after restore. For this:\nImplement methods that are used for notification import org.crac.Context; import org.crac.Core; import org.crac.Resource; class ServerManager implements Resource { ... @Override public void beforeCheckpoint(Context\u003c? extends Resource\u003e context) throws Exception { server.stop(); } @Override public void afterRestore(Context\u003c? extends Resource\u003e context) throws Exception { server.start(); } } Register the object in a Context that will invoke the Resource’s methods as notification. There is a global Context that can be used as default choice. public ServerManager(int port, Handler handler) throws Exception { ... Core.getGlobalContext().register(this); } This example is a special by presence of a single non-daemon thread owned by Jetty that keeps JVM from exit. When server.stop() is called the thread exits and so does the JVM instead of the checkpoint. To prevent this and for simplicity of example, we add another non-daemon thread that makes JVM running when the Jetty stops.\npublic ServerManager(int port, Handler handler) throws Exception { ... Core.getGlobalContext().register(this); preventExitThread = new Thread(() -\u003e { while (true) { try { Thread.sleep(1_000_000); } catch (InterruptedException e) { } } }); preventExitThread.start(); } Now jcmd should make the app to print next in the console and exit:\n2020-06-29 18:01:56.566:INFO:oejs.AbstractConnector:Thread-9: Stopped ServerConnector@319b92f3{HTTP/1.1, (http/1.1)}{0.0.0.0:8080} CR: Checkpoint ... Killed The image can be used to start another instances:\n$ $JAVA_HOME/bin/java -XX:CRaCRestoreFrom=cr 2020-06-29 18:06:45.939:INFO:oejs.Server:Thread-9: jetty-9.4.30.v20200611; built: 2020-06-11T12:34:51.929Z; git: 271836e4c1f4612f12b7bb13ef5a92a927634b0d; jvm 14-internal+0-adhoc..jdk 2020-06-29 18:06:45.942:INFO:oejs.AbstractConnector:Thread-9: Started ServerConnector@319b92f3{HTTP/1.1, (http/1.1)}{0.0.0.0:8080} 2020-06-29 18:06:45.943:INFO:oejs.Server:Thread-9: Started @293756ms",
    "description": "Step-by-step CRaC support for a Jetty app A program can be restored in a different environment compared to the one where it was checkpointed. Dependencies on the environment need to be detected and a coordination code need to be created to update the dependencies after restore. Such dependencies are open handles for operating system resources like files and sockets, cached hostname and environment, registration in remote services, …\nFor now, CRaC implementation checks for open files and sockets at the checkpoint. The checkpoint is aborted if one is found, also, an exception is thrown with a description of the file name or socket address.",
    "tags": [],
    "title": "Jetty",
    "uri": "/examples/jetty/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Frameworks with CRaC integration",
    "content": "You can just add crac feature at https://micronaut.io/launch!\nMicronaut CRaC Module Hikari DataSources coordination Redis coordintation Build System a single command to generate a docker image with CRaC image included Example: https://github.com/CRaC/example-micronaut",
    "description": "You can just add crac feature at https://micronaut.io/launch!\nMicronaut CRaC Module Hikari DataSources coordination Redis coordintation Build System a single command to generate a docker image with CRaC image included Example: https://github.com/CRaC/example-micronaut",
    "tags": [],
    "title": "Micronaut",
    "uri": "/frameworks/micronaut/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Example implementations",
    "content": "This guide will walk you through the process of taking an existing non-trivial application and getting it CRaC-able. The workshop describes the application, please refer there for any details. We’ll start right away with the result of that workshop:\nMake sure that JAVA_HOME points to OpenJDK CRaC JDK, and ensure that CRaC works (CRIU has correct permissions etc). Checkout and build Super Heroes: git clone https://github.com/quarkusio/quarkus-workshops cd quarkus-workshops/quarkus-workshop-super-heroes ./mvnw clean package -DskipTests -Pcomplete Run the infrastructure: docker-compose -f super-heroes/infrastructure/docker-compose.yaml up -d Start the UI $JAVA_HOME/bin/java -jar super-heroes/ui-super-heroes/target/quarkus-app/quarkus-run.jar In individual consoles start the microservices $JAVA_HOME/bin/java -XX:CRaCCheckpointTo=/tmp/heroes -jar super-heroes/rest-heroes/target/quarkus-app/quarkus-run.jar $JAVA_HOME/bin/java -XX:CRaCCheckpointTo=/tmp/villains -jar super-heroes/rest-villains/target/quarkus-app/quarkus-run.jar $JAVA_HOME/bin/java -XX:CRaCCheckpointTo=/tmp/fights \\ -Dquarkus.http.cors.origins='*' \\ -Dcom.arjuna.ats.internal.arjuna.utils.processImplementation=com.arjuna.ats.internal.arjuna.utils.UuidProcessId \\ -jar super-heroes/rest-fights/target/quarkus-app/quarkus-run.jar Note that the property selecting Arjuna’s processImplementation is not necessary at this point; we’ll need that later, though.\nOpen http://localhost:8080, click on ‘New fighters’ and ‘Fight’ a few times. It seems that there is a bug in the original application: the first request usually fails due to a timeout. This is unrelated to CRaC, and since subsequent requests usually succeed we can just reload the site (Ctrl+F5 in most browsers) and see that the application works correctly.\nCheckpoint the three microservices: for pid in $(jps -l | grep super-heroes/rest- | cut -f 1 -d ' '); do jcmd $pid JDK.checkpoint; done; CRaC will experience some problems due to files or network connection being open:\n1586473: An exception during a checkpoint operation: jdk.crac.CheckpointException at java.base/jdk.crac.Core.checkpointRestore1(Core.java:182) at java.base/jdk.crac.Core.checkpointRestore(Core.java:287) at java.base/jdk.crac.Core.checkpointRestoreInternal(Core.java:303) Suppressed: jdk.crac.impl.CheckpointOpenSocketException: tcp6 localAddr ::ffff:127.0.0.1 localPort 48768 remoteAddr ::ffff:127.0.0.1 remotePort 5432 at java.base/jdk.crac.Core.translateJVMExceptions(Core.java:120) at java.base/jdk.crac.Core.checkpointRestore1(Core.java:186) ... 2 more 1586666: CR: Checkpoint ... 1586548: An exception during a checkpoint operation: jdk.crac.CheckpointException at java.base/jdk.crac.Core.checkpointRestore1(Core.java:122) at java.base/jdk.crac.Core.checkpointRestore(Core.java:246) at java.base/jdk.crac.Core.checkpointRestoreInternal(Core.java:262) Suppressed: java.nio.channels.IllegalSelectorException at java.base/sun.nio.ch.EPollSelectorImpl.beforeCheckpoint(EPollSelectorImpl.java:384) at java.base/jdk.crac.impl.AbstractContextImpl.beforeCheckpoint(AbstractContextImpl.java:66) at java.base/jdk.crac.impl.AbstractContextImpl.beforeCheckpoint(AbstractContextImpl.java:66) at java.base/jdk.crac.Core.checkpointRestore1(Core.java:120) ... 2 more Suppressed: jdk.crac.impl.CheckpointOpenSocketException: tcp6 localAddr ::ffff:127.0.0.1 localPort 51778 remoteAddr ::ffff:127.0.0.1 remotePort 9092 at java.base/jdk.crac.Core.translateJVMExceptions(Core.java:91) at java.base/jdk.crac.Core.checkpointRestore1(Core.java:145) ... 2 more Suppressed: jdk.crac.impl.CheckpointOpenSocketException: tcp6 localAddr ::ffff:127.0.0.1 localPort 52200 remoteAddr ::ffff:127.0.0.1 remotePort 5432 at java.base/jdk.crac.Core.translateJVMExceptions(Core.java:91) at java.base/jdk.crac.Core.checkpointRestore1(Core.java:145) ... 2 more Suppressed: jdk.crac.impl.CheckpointOpenResourceException: anon_inode:[eventpoll] at java.base/jdk.crac.Core.translateJVMExceptions(Core.java:97) at java.base/jdk.crac.Core.checkpointRestore1(Core.java:145) ... 2 more Suppressed: jdk.crac.impl.CheckpointOpenResourceException: anon_inode:[eventfd] at java.base/jdk.crac.Core.translateJVMExceptions(Core.java:97) at java.base/jdk.crac.Core.checkpointRestore1(Core.java:145) ... 2 more Suppressed: jdk.crac.impl.CheckpointOpenSocketException: tcp6 localAddr ::ffff:127.0.0.1 localPort 58142 remoteAddr ::ffff:127.0.0.1 remotePort 9092 at java.base/jdk.crac.Core.translateJVMExceptions(Core.java:91) at java.base/jdk.crac.Core.checkpointRestore1(Core.java:145) ... 2 more In a framework like Quarkus it is not up to the application to handle this, framework should listen to CRaC notifications and close/reopen them. This guide won’t describe how these problems can be identified and fixed, please see debugging guide for that. Instead we will use version of dependencies that has these issues handled.\nReplacing CRaC non-compatible artifacts The vanilla version of Quarkus Super Heroes relies on artifacts that do not handle checkpoint and this would fail due to open files or sockets. Until CRaC becomes mainstream and these libraries handle notifications we provide a CRaC-ed version with some of the problems fixed.\nIn order to identify these dependencies before running into errors we have created a Maven Enforcer rule that can be included in the build and highlights the incompatible artifacts:\n\u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-enforcer-plugin\u003c/artifactId\u003e \u003cversion\u003e3.3.0\u003c/version\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eio.github.crac\u003c/groupId\u003e \u003cartifactId\u003ecrac-enforcer-rule\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cgoals\u003e \u003cgoal\u003eenforce\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003cconfiguration\u003e \u003crules\u003e \u003ccracDependencies /\u003e \u003c/rules\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e Now when you try to build the project, the enforcer will spit out errors, including suggestions for a replacement artifact:\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-enforcer-plugin:3.3.0:enforce (default) on project rest-villains: [ERROR] Rule 0: io.github.crac.CracDependencies failed with message: [ERROR] io.quarkus.workshop.super-heroes:rest-villains:jar:1.0.0-SNAPSHOT [ERROR] io.quarkus:quarkus-resteasy-reactive:jar:2.15.3.Final [ERROR] io.quarkus.resteasy.reactive:resteasy-reactive-vertx:jar:2.15.3.Final [ERROR] io.vertx:vertx-web:jar:4.3.6 [ERROR] io.vertx:vertx-web-common:jar:4.3.6 [ERROR] io.vertx:vertx-core:jar:4.3.6 \u003c--- replace with io.github.crac.io.vertx:vertx-core:4.3.8.CRAC.0 [ERROR] io.vertx:vertx-auth-common:jar:4.3.6 [ERROR] io.vertx:vertx-core:jar:4.3.6 \u003c--- replace with io.github.crac.io.vertx:vertx-core:4.3.8.CRAC.0 [ERROR] io.vertx:vertx-bridge-common:jar:4.3.6 [ERROR] io.vertx:vertx-core:jar:4.3.6 \u003c--- replace with io.github.crac.io.vertx:vertx-core:4.3.8.CRAC.0 [ERROR] io.vertx:vertx-core:jar:4.3.6 \u003c--- replace with io.github.crac.io.vertx:vertx-core:4.3.8.CRAC.0 [ERROR] io.smallrye.reactive:smallrye-mutiny-vertx-core:jar:2.29.0 [ERROR] io.smallrye.reactive:smallrye-mutiny-vertx-runtime:jar:2.29.0 [ERROR] io.vertx:vertx-core:jar:4.3.6 \u003c--- replace with io.github.crac.io.vertx:vertx-core:4.3.8.CRAC.0 [ERROR] io.vertx:vertx-core:jar:4.3.6 \u003c--- replace with io.github.crac.io.vertx:vertx-core:4.3.8.CRAC.0 [ERROR] io.quarkus:quarkus-vertx-http:jar:2.15.3.Final [ERROR] io.smallrye.common:smallrye-common-vertx-context:jar:1.13.2 [ERROR] io.vertx:vertx-core:jar:4.3.6 \u003c--- replace with io.github.crac.io.vertx:vertx-core:4.3.8.CRAC.0 [ERROR] io.smallrye.reactive:smallrye-mutiny-vertx-web:jar:2.29.0 [ERROR] io.smallrye.reactive:smallrye-mutiny-vertx-uri-template:jar:2.29.0 [ERROR] io.vertx:vertx-uri-template:jar:4.3.6 [ERROR] io.vertx:vertx-core:jar:4.3.6 \u003c--- replace with io.github.crac.io.vertx:vertx-core:4.3.8.CRAC.0 [ERROR] io.quarkus:quarkus-hibernate-orm-panache:jar:2.15.3.Final [ERROR] io.quarkus:quarkus-hibernate-orm:jar:2.15.3.Final [ERROR] io.quarkus:quarkus-agroal:jar:2.15.3.Final [ERROR] io.agroal:agroal-pool:jar:1.16 \u003c--- replace with io.github.crac.io.agroal:agroal-pool:1.18.CRAC.0 The offending dependencies can be removed using \u003cexclusions\u003e, and CRaC’ed dependencies should be added. Usually these have groupId prefixed with org.github.crac., artifactId is identical and version is suffixed with .CRAC.N where N stands for counter of CRaC-related changes; these should be added on top of the original (tagged) version.\n\u003cdependency\u003e \u003cgroupId\u003eio.quarkus\u003c/groupId\u003e \u003cartifactId\u003equarkus-resteasy-reactive\u003c/artifactId\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eio.vertx\u003c/groupId\u003e \u003cartifactId\u003evertx-core\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.github.crac.io.vertx\u003c/groupId\u003e \u003cartifactId\u003evertx-core\u003c/artifactId\u003e \u003cversion\u003e4.3.8.CRAC.0\u003c/version\u003e \u003c/dependency\u003e It’s likely that there won’t be a CRaC’ed version exactly matching the original version; please test for any compatibility issues thoroughly.\nTo see the ‘patched’ version please see this fork. To use the Maven Enforcer conveniently we have added a parent module to the microservices and set up Maven Enforcer.\ngit remote add rvansa https://github.com/rvansa/quarkus-workshops.git git fetch rvansa crac \u0026\u0026 checkout rvansa/crac Runnning the patched version Make sure that the non-patched version of the microservices is not running anymore, e.g. using Ctrl+C in console.\nRebuild the patched microservices using ./mvnw clean package -DskipTests -Pcomplete\nRepeat steps 5 - 7 from the previous attempt, starting the apps, issuing a few requests through UI and performing the checkpoint.\nThe checkpoint might fail for some services: In this scenario Quarkus loads some classes during checkpoint (e.g. from finalizers or when closing connections), opening some files. This may happen after the code that was supposed to close all cached open files has executed, and leads to checkpoint failure. If this is the case please trigger checkpoint again; this time everything should be loaded and the checkpoint should succeed.\nRestore the services in individual consoles: $JAVA_HOME/bin/java -jar -XX:CRaCRestoreFrom=/tmp/heroes $JAVA_HOME/bin/java -jar -XX:CRaCRestoreFrom=/tmp/villains $JAVA_HOME/bin/java -jar -XX:CRaCRestoreFrom=/tmp/fights Go to http://localhost:8080 and try to click through the UI few times. You can check consoles to see that everything works. Side note: The Super Heroes workshop includes one more microservice, the event-statistics. This microservice hasn’t been CRaC’ed yet as it requires some additional fixes in Kafka.",
    "description": "This guide will walk you through the process of taking an existing non-trivial application and getting it CRaC-able. The workshop describes the application, please refer there for any details. We’ll start right away with the result of that workshop:\nMake sure that JAVA_HOME points to OpenJDK CRaC JDK, and ensure that CRaC works (CRIU has correct permissions etc). Checkout and build Super Heroes: git clone https://github.com/quarkusio/quarkus-workshops cd quarkus-workshops/quarkus-workshop-super-heroes ./mvnw clean package -DskipTests -Pcomplete Run the infrastructure: docker-compose -f super-heroes/infrastructure/docker-compose.yaml up -d Start the UI $JAVA_HOME/bin/java -jar super-heroes/ui-super-heroes/target/quarkus-app/quarkus-run.jar In individual consoles start the microservices $JAVA_HOME/bin/java -XX:CRaCCheckpointTo=/tmp/heroes -jar super-heroes/rest-heroes/target/quarkus-app/quarkus-run.jar $JAVA_HOME/bin/java -XX:CRaCCheckpointTo=/tmp/villains -jar super-heroes/rest-villains/target/quarkus-app/quarkus-run.jar $JAVA_HOME/bin/java -XX:CRaCCheckpointTo=/tmp/fights \\ -Dquarkus.http.cors.origins='*' \\ -Dcom.arjuna.ats.internal.arjuna.utils.processImplementation=com.arjuna.ats.internal.arjuna.utils.UuidProcessId \\ -jar super-heroes/rest-fights/target/quarkus-app/quarkus-run.jar Note that the property selecting Arjuna’s processImplementation is not necessary at this point; we’ll need that later, though.",
    "tags": [],
    "title": "Quarkus Super Heroes",
    "uri": "/examples/super-heroes/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Frameworks with CRaC integration",
    "content": "AWS Libs with CRaC allows implementation of AWS Lambda functions on CRaC JDK.\nArtifacts: https://mvnrepository.com/artifact/io.github.crac.com.amazonaws\nExample: https://github.com/crac/example-lambda (diff) is a sample Java serverless function on CRaC.\nChanges: https://github.com/CRaC/aws-lambda-java-libs/compare/master...crac",
    "description": "AWS Libs with CRaC allows implementation of AWS Lambda functions on CRaC JDK.\nArtifacts: https://mvnrepository.com/artifact/io.github.crac.com.amazonaws\nExample: https://github.com/crac/example-lambda (diff) is a sample Java serverless function on CRaC.\nChanges: https://github.com/CRaC/aws-lambda-java-libs/compare/master...crac",
    "tags": [],
    "title": "AWS Lambda",
    "uri": "/frameworks/aws-lambda/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Extra info about CRaC",
    "content": "CPU features differ from host to host as newer CPUs offer support for newer instructions, and some optional features may be removed over time. JVM (Java Virtual Machine) depends on CPU features (such as AVX512, SSE3 etc.) of each computer it is running on. The more CPU features JVM can use the better performance it can provide. JVM normally uses all the CPU features it can find on the CPU where it has started.\nCRaC unfortunately cannot reconfigure an already running JVM to stop using some of the CPU features when being restored on a CPU which is missing those features. You may create a snapshot (-XX:CRaCCheckpointTo=PATH) on a newer computer and restore it (-XX:CRaCRestoreFrom=PATH) on an older computer. In such case you may see during restore a variant of error message\n$JAVA_HOME/bin/java -XX:CRaCRestoreFrom=cr You have to specify -XX:CPUFeatures=0x21421801fcfbd7,0x3e6 together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features 0x4ff7fff9dfcfbf7,0x3e6; missing features of this CPU are 0x4de3de79c000020,0x0 = 3dnowpref, adx, avx512f, avx512dq, avx512cd, avx512bw, avx512vl, sha, avx512_vpopcntdq, avx512_vpclmulqdq, avx512_vaes, avx512_vnni, clflushopt, clwb, avx512_vbmi2, avx512_vbmi, rdpid, fsrm, gfni, avx512_bitalg, pku, ospke, avx512_ifma If you are sure it will not crash you can override this check by -XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures . \u003cJVM exits here\u003e Just follow the advice from the complaining system running -XX:CRaCRestoreFrom=PATH when configuring the initial system creating the snapshot (-XX:CRaCCheckpointTo=PATH).\n$JAVA_HOME/bin/java -XX:CRaCCheckpointTo=cr -XX:CPUFeatures=0x21421801fcfbd7,0x3e6 -jar target/spring-boot-0.0.1-SNAPSHOT.jar -XX:CPUFeatures=generic If the CRaC image is restored on computers with different CPU features the most simple solution is to just run Java with\n$JAVA_HOME/bin/java -XX:CRaCCheckpointTo=cr -XX:CPUFeatures=generic -jar target/spring-boot-0.0.1-SNAPSHOT.jar Unfortunately the run then has suboptimal performance. Still the difference may not be even measurable. For obtaining an optimal performance continue reading Merging CPU Features.\nMerging CPU Features If the CRaC image is restored on computers with different CPU features you may need to use logical and (\u0026) of the suggested -XX:CPUFeatures option.\ncomputer A used for an image restore: You have to specify -XX:CPUFeatures=0x21421801fcfbd7,0x3e6 together with -XX:CRaCCheckpointTo when making a checkpoint file; [...] computer B used for an image restore: You have to specify -XX:CPUFeatures=0x4b03c643c9869,0x173 together with -XX:CRaCCheckpointTo when making a checkpoint file; [...] compute common minimal set of features of computers A and B: python -c 'print(hex(0x21421801fcfbd7 \u0026 0x4b03c643c9869)+\",\"+hex(0x3e6 \u0026 0x173));' 0x18003c9841,0x162 computer used for the image snapshot: $JAVA_HOME/bin/java -XX:CRaCCheckpointTo=cr -XX:CPUFeatures=0x18003c9841,0x162 -jar target/spring-boot-0.0.1-SNAPSHOT.jar -XX:+ShowCPUFeatures To easily detect parameters for the -XX:CPUFeatures option on the computer intended to run the -XX:CRaCRestoreFrom=PATH option you may use the option -XX:+ShowCPUFeatures. Using --version as in this example is not mandatory but otherwise the CPU features may scroll away.\n$JAVA_HOME/bin/java -XX:+ShowCPUFeatures --version This machine's CPU features are: -XX:CPUFeatures=0x4ff7fff9dfcfbf7,0x3e6 CPU features being used are: -XX:CPUFeatures=0x4ff7fff9dfcfbf7,0x3e6 openjdk 22-internal 2024-03-19 OpenJDK Runtime Environment (fastdebug build 22-internal-adhoc.azul.crac-git) OpenJDK 64-Bit Server VM (fastdebug build 22-internal-adhoc.azul.crac-git, mixed mode) -XX:+IgnoreCPUFeatures In some cases when you get the error\n$JAVA_HOME/bin/java -XX:CRaCRestoreFrom=cr You have to specify -XX:CPUFeatures=0x21421801fcfbd7,0x3e6 together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features 0x4ff7fff9dfcfbf7,0x3e6; missing features of this CPU are 0x4de3de79c000020,0x0 = 3dnowpref, adx, avx512f, avx512dq, avx512cd, avx512bw, avx512vl, sha, avx512_vpopcntdq, avx512_vpclmulqdq, avx512_vaes, avx512_vnni, clflushopt, clwb, avx512_vbmi2, avx512_vbmi, rdpid, fsrm, gfni, avx512_bitalg, pku, ospke, avx512_ifma If you are sure it will not crash you can override this check by -XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures . \u003cJVM exits here\u003e You may be sure the missing CPU feature is not really required for the run of JVM. You can enforce JVM to run even in such a case. Logically JVM may crash by segmentation fault (on UNIX) or other fatal error (on MS-Windows) later during its run due to the missing CPU feature(s). You have been warned.\n$JAVA_HOME/bin/java -XX:CRaCRestoreFrom=cr -XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures You have to specify -XX:CPUFeatures=0x21421801fcfbd7,0x3e6 together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features 0x4ff7fff9dfcfbf7,0x3e6; missing features of this CPU are 0x4de3de79c000020,0x0 = 3dnowpref, adx, avx512f, avx512dq, avx512cd, avx512bw, avx512vl, sha, avx512_vpopcntdq, avx512_vpclmulqdq, avx512_vaes, avx512_vnni, clflushopt, clwb, avx512_vbmi2, avx512_vbmi, rdpid, fsrm, gfni, avx512_bitalg, pku, ospke, avx512_ifma If you are sure it will not crash you can override this check by -XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures . \u003cJVM continues its execution here\u003e -XX:CPUFeatures=ignore If you have any problems with this CPU features handling code you can disable it completely by:\n$JAVA_HOME/bin/java -XX:CRaCCheckpointTo=cr -XX:CPUFeatures=ignore -jar target/spring-boot-0.0.1-SNAPSHOT.jar Please provide a feedback to the CRaC project in such a case.\n-XX:CPUFeatures=native -XX:CPUFeatures=native is the default. You may want to use it to override another -XX:CPUFeatures option specified earlier on your command line.",
    "description": "CPU features differ from host to host as newer CPUs offer support for newer instructions, and some optional features may be removed over time. JVM (Java Virtual Machine) depends on CPU features (such as AVX512, SSE3 etc.) of each computer it is running on. The more CPU features JVM can use the better performance it can provide. JVM normally uses all the CPU features it can find on the CPU where it has started.",
    "tags": [],
    "title": "CPU Features",
    "uri": "/extra-info/cpu-features/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Using CRaC",
    "content": "WARNING: next is a proposal phase and is subject to change\nPlease refer to the Projects with CRaC support section, step-by-step guide or best practices guide to get an application with CRaC support. The rest of the section is written for the spring-boot example.\nFor the first, Java command line parameter -XX:CRaCCheckpointTo=PATH defines a path to store the image and also allows the java instance to be checkpointed. By the current implementation, the image is a directory with image files. The directory will be created if it does not exist, but no parent directories are created.\nexport JAVA_HOME=./jdk $JAVA_HOME/bin/java -XX:CRaCCheckpointTo=cr -jar target/example-spring-boot-0.0.1-SNAPSHOT.jar For the second, in another console: supply canary worload …\n$ curl localhost:8080 Greetings from Spring Boot! … and make a checkpoint by a jcmd command\n$ jcmd target/example-spring-boot-0.0.1-SNAPSHOT.jar JDK.checkpoint 1563568: Command executed successfully Due to current jcmd implementation, success is always reported in jcmd output, problems are reported in the console of the application.\nAnother option to make the checkpoint is to invoke the jdk.crac.Core.checkpointRestore() method (see API). More options are possible in the future.\nFor the third, restore the cr image by -XX:CRaCRestoreFrom=PATH option\n$JAVA_HOME/bin/java -XX:CRaCRestoreFrom=cr",
    "description": "WARNING: next is a proposal phase and is subject to change\nPlease refer to the Projects with CRaC support section, step-by-step guide or best practices guide to get an application with CRaC support. The rest of the section is written for the spring-boot example.\nFor the first, Java command line parameter -XX:CRaCCheckpointTo=PATH defines a path to store the image and also allows the java instance to be checkpointed. By the current implementation, the image is a directory with image files. The directory will be created if it does not exist, but no parent directories are created.",
    "tags": [],
    "title": "Creating a Checkpoint and Restoring from Checkpoint",
    "uri": "/use/checkpoint-and-restore/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint",
    "content": "Proof-of-Concept CRaC support implementation Proof-of concept CRaC support was implemented in a few third-party frameworks and libraries.\nSource code links are below. Builds can be found in Maven Central under io.github.crac artifact-id.\nFrameworks Several frameworks provide CRaC functionality out-of-the-box.\nSpringBoot Quarkus Micronaut AWS Lambda",
    "description": "Proof-of-Concept CRaC support implementation Proof-of concept CRaC support was implemented in a few third-party frameworks and libraries.\nSource code links are below. Builds can be found in Maven Central under io.github.crac artifact-id.\nFrameworks Several frameworks provide CRaC functionality out-of-the-box.\nSpringBoot Quarkus Micronaut AWS Lambda",
    "tags": [],
    "title": "Frameworks with CRaC integration",
    "uri": "/frameworks/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint \u003e Extra info about CRaC",
    "content": "CRaC requires that the application closes all open files, network connections etc. - on Linux these are represented as file descriptors. However, it might be difficult to alter the application to properly coordinate with the checkpoint, e.g. due to a code in a library you cannot modify. In those cases CRaC offers a limited handling via configuration. Note that this applies only to file descriptors opened through JDK API; anything opened through native code cannot be handled this way.\nThe configuration is set up by pointing system property jdk.crac.resource-policies to a file that consists of several rules separated by three dashes (---). Lines starting with hash sign (#) are ignored. Each rule consists of several key: value pairs. The above is actually a subset of YAML format, so we suggest that you use the .yaml or .yml extension for convenient use in an editor. See an example of this file:\ntype: file path: /path/to/my/file action: close --- # Here is some comment type: FILE path: **/*.log action: reopen Each rule has two mandatory properties: type and action, with case-insensitive values. Available types are:\nfile: a file (or directory) on a local filesystem pipe: an anonymous pipe - named pipes are handled using the type file socket: network (TCP, UDP, …) or unix socket filedescriptor: raw file descriptor that cannot be identified by any of the above The order of rules in the file is important; for each file descriptor found open the first matching rule will be applied, any subsequent rules are ignored.\nFiles As the first example shows, files can be selected using the path property. This supports ‘glob’ pattern matching - see java.nio.file.FileSystem.getPathMatcher() javadoc for detailed usage. These are the possible actions:\nerror: The default action, just print error and fail the checkpoint. ignore: Leave handling of the open file to C/R engine (CRIU). This will likely validate and reopen the file on restore. close: Close the file. An attempt to use it after restore will fail with runtime exception. reopen: Close the file, and try reopen it (on the same position) after restore. Unless the action is error, any file found open will trigger a warning to be printed to the logging system. This can be suppressed with warn: false property.\nPipes Anonymous pipes don’t have any means to identify, therefore it makes sense to have at most one rule for these. Available actions are error, ignore and close with the same meaning as in case of files.\nSockets The rule can be refined using one of these properties:\nfamily: ipv6 or inet6 for IPv6 sockets, ipv4 or inet4 for IPv4 sockets, ip or inet for any IPv4/IPv6, unix for Unix domain sockets localAddress and remoteAddress: * could be used for any bound address localPort and remotePort: numeric port, * matches any port localPath and remotePath: for Unix sockets, supports ‘glob’ pattern matching Actions error, ignore and close apply as in the previous cases. It is possible to use action reopen, too - this will close the socket before checkpoint, but the reopening part is not implemented, therefore will result in a runtime exception after restore. Eventually this will be implemented for listening sockets.\nRaw file descriptors In some cases we might find that file descriptor was created without a matching higher-level object (e.g. FileOutputStream). Such descriptor can be identified either with its numeric value, using value: 123, or matching its native description: regex: .*something.* following the java.util.regex.Pattern.compile() syntax.\nFor raw descriptors, only the error, ignore and close actions are available.",
    "description": "CRaC requires that the application closes all open files, network connections etc. - on Linux these are represented as file descriptors. However, it might be difficult to alter the application to properly coordinate with the checkpoint, e.g. due to a code in a library you cannot modify. In those cases CRaC offers a limited handling via configuration. Note that this applies only to file descriptors opened through JDK API; anything opened through native code cannot be handled this way.",
    "tags": [],
    "title": "File descriptor policies",
    "uri": "/extra-info/fd-policies/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint",
    "content": "Some more detailed info about CRaC is available on these pages:\nBest Practices Debugging CPU Features File descriptor policies",
    "description": "Some more detailed info about CRaC is available on these pages:\nBest Practices Debugging CPU Features File descriptor policies",
    "tags": [],
    "title": "Extra info about CRaC",
    "uri": "/extra-info/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Coordinated Restore at Checkpoint",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
